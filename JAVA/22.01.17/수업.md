## 1교시
- 메소드 !!     
이클립스의 src = 소스파일(모든 프로그래밍 언어에 다 있다.)      
src 오른쪽 클릭으로 "메소드" 패키지 만들고, 다시 그 아래 클래스 만들기      
public static void 체크 못했을면 main 쓰고 ctrl + 스페이스바로 만들기       

- 메소드(함수, 기능)란?     
무언가를 개발하기 위해서 기능을 나눠야 함. 로봇의 각각의 기능을 쪼개야 함.      
각 기능을 분리해서 개발(응집도는 높고 결합도는 낮게)해야 소프트웨어 품질 향상.           
로봇의 팔과 다리 소스를 결합도 높게 만들면 나중에 하나가 고장났을 때 둘 다 봐야하는 문제가 생긴다.     
함수를 잘 만들어 놓으면 나중에 어딜가든 재사용할 수 있다!!      

- main : 자바에서 먼저 실행되는 함수(기능)      
static이 붙은 함수에는 static 함수만 올 수 있다.        

- 
```
	public static void printName() {
		System.out.println("Hello World");
	}
	public static void main(String[] args) {
		printName();
	}
```

- 접근지정자(4개) : public, private, protected, 디폴트 접근지정자       
객체지향 언어는 대부분 4개의 접근지정자가 있다.     
실무에서는 public과 private만 쓴다.     

- public        
public으로 지정하면 다른 클래스파일에서 메소드를 재사용할 수 있다.      

- 문법      
<접근지정자> <리턴타입> <함수 이름> (인자값)        
*함수 이름은 동사로 지정해야 됨!     
if에서의 괄호는 조건식 비교용, 메소드에서 괄호는 인자값
```
public int getSum(int x, int y) {
    int sum = 10;
    // 리턴타입이 int형이면 int형 데이터를 반환(return)해야 함.     
    return sum;
}
```
getSum 함수는 int x 라는 값을 받을 준비가 되어있다.    
인자값에는 제한이 없지만 최대 3개까지만 지정하는것이 암묵적 규칙        
인자값 = 파라미터값 (명칭이 여러가지임)     

리턴타입은 최종적으로 구하고자 하는 값의 데이터타입이다.     

- 
```
	public static int getNumber() {
		int x = 10;
		if (x == 10) {
			x = 5;
		}
		return x;
	} // x의 생명은 여기까지!

	public static void main(String[] args) {
		int x = getNumber(); // 새로운 int x 에 겟넘버 값 대입
		System.out.println("x 값은 "+x);
	}
```
## 2교시
- 한번 함수를 지정하면 계속 쓸 수 있다.
```
	public static int 성적계산(int 국어점수, int 수학점수) {
		int sum = 국어점수 + 수학점수; // sum이란 변수 없이 return 국어점수 + 수학점수; 라고 해도 되지만 최대한 변수를 사용하는게 낫다.
		return sum;
	}

	public static void main(String[] args) {
		// 성적처리하는 알고리즘...
		int 수학점수 = 100; // 실무에선 DB에서 값들을 불러온다.
		int 국어점수 = 0;
		int 총합은 = 성적계산(국어점수, 수학점수);
    	System.out.println(총합은);
```

- 합을 구하는 메소드를 한번 만들면 나중에 계속해서 사용할 수 있다.
```
	public static int getSum(int max) {
		int sum = 0;
		for (int i = 1; i <= max; i++) {
			sum += i;
			// if(sum == 30){
			// return sum; 
			// } 
            // 중간에 리턴을 하면 반복을 바로 중지하고 리턴시킴. 아래에 어떤 값이 있든 무시함.
		}
		return sum;
	}

	public static void main(String[] args) {
		int result = getSum(10); // 10이 위에 int max로 대입됨
		System.out.println(result);
	}
```
## 3교시
- 메소드 분리 잘 하는 것이 관건!!       
1. 리턴타입      
메소드의 최종 결과값을 반환.        
리턴 타입에는 데이터타입 8개(int, double, long, float, ...)와 클래스타입 1개(String) 총 9개가 위치.       
리턴 타입이 없을 때는 void로 표현       

2. 인자값(파라미터값)     
데이터 타입 8개 + 클래스 타입 1개  
인자값이 없을 때는 () 빈 괄호       
*** 인자값(파라미터값)은 3개 이하로 작성 : 보기 쉽게하기 위함       

3. 접근지정자       
 1) public : 다른 클래스에서 호출 가능      
 2) private : 내부 클래스에서만 호출 가능       
 3)protected
 4) defalut

- 거스름돈 메소드 문제       
```
	// 돈을 입력받고 만원 몇장인지 return!
	// 단, 만원 미만으로 파라미터값이 오면 0 리턴할 것
	public static int 거스름돈(int money) { // 메소드 시작
		final int MAN = 10000; // MAN 정의
		if (money < MAN) { // 파라미터가 만원 미만인 경우
			return 0; // 0으로 리턴, 아래 코드 무시
		}
		int result = money / MAN; // 결과값은 money를 MAN으로 나눈 몫
		return result; // 결과값 리턴해서 아래로 보냄
	}

	public static void main(String[] args) {
		int money = 50000; // 메소드에 대입할 값
		int 만원몇장 = 거스름돈(money); // 메소드 불러옴(호출)
		System.out.println(만원몇장+" 장"); // 메소드 결과값
	}
```
- 메소드 이름위에 커서를 올려 놓으면 위치와 리턴타입을 볼 수 있다.     
- println의 리턴타입은 없음(void) 그리고 괄호 안에 string이 온다.       

- 문제
```
	// x, y에 데이터를 넣고, 더한 값을 리턴하는 메소드를 작성하고 main 메소드에 호출
	// 단, x는 10 미만이면 x에 5를 대입
	public static int getSum(int x, int y) {
		if (x < 10) {
			x = 5; // x에 5를 대입한다고 해서 return x=5로 해버리면 답이 5만 나온다.
		int sum = x + y;
		return sum;
	}

	public static void main(String[] args) {
		int x = 2;
		int y = 10;
		int 총합은 = getSum(x, y);
		System.out.println(총합은);
	}
```

## 4교시
- 메소드를 사용하는 이유        
재사용성 증가, 코드 간결        
들어오는 값만 다르고 출력하는 방법은 같다.      
파라미터 순서에 맞게! 값을 넣어줘야 한다. 순서가 다르면 오류 남.        
각 파라미터 값을 직접 숫자로 대입하기 보다 그 파라미터가 어떤걸 의미하는지 함수를 지정해 주는게 좋은 코드이다.
```    
다음과 같이 int 로 지정해주고 파라미터 안에 함수 이름으로 부른다. 
int 순대개수 = 30; 
int 내장 = 50;       
순대국밥(순대개수,내장)
```

- 문제
```
	// x, y에 데이터를 넣고 x가 크면 x를 리턴, y가 크면 y를 리턴
	// 단, x와 y에 데이터는 100을 넘을 수가 없다.
	public static int getSum02(int x, int y) {

		if (x > y) {
			if (x <= 100)
				return x;
		}
		if (y > x) {
			if (y <= 100)
				return y;
		}
		return 0; 
        // 컴퓨터는 혹시모를 if가 틀릴경우를 대비해서 마지막 줄에 return 0; 을 꼭 써줘야 한다.
		// 또는 else { return; } 으로 선택지를 없게 만들 수도 있다.
	}

	public static void main(String[] args) {
		int x = 50;
		int y = 30;
		int 결과 = getSum02(x, y);
		System.out.println(결과);
	}
```
```
위에 메소드에 다음과 같이 표현해도 된다.
		if (x > 100 || y > 100) {
			return 0;
		}
		if (x > y) {
			return x;
		}
		if (y > x) {
			return y;
		}
		return 0;
```

## 5교시
*** 메소드 문법 외우기!      
<접근지정자> <리턴타입> <함수 이름> (인자값,파라미터값)        
접근지정자 = public, private, protected, default        
리턴타입 = int, double, String, void(리턴 없으면)       
함수이름 = 동사     
인자값(파라미터값) = int, double, String        

## 6교시
```
	// 1부터 100까지 짝수 개수 구하기
	// 조건 1) startNum이 endNum보다 크거나 같으면 return 0
	// 조건 2) endNum이 100을 초과하면 return 0
	public static int getCount(int startNum, int endNum) {
		// 조건(if)을 앞에 둬야 필터링이 될 수 있다!! 함수(for)가 실행되기 전에 걸러내야 의미가 있다.
		if (startNum >= endNum) { 
			return 0;
		}
		if (endNum > 100) {
			return 0;
		}
		int count = 0;
		for (int i = startNum; i < endNum; ++i) {
			if ((i % 2) == 0) {
				count += 1; // ++count;
			}
			// if(startNum >= endNum && endNum > 100) return 0;
		}
		return count;
	}

	public static void main(String[] args) {
		getCount(1, 100);
	}
```

## 7교시
- 문제 1
```
	public static int 배열받아보자(int[] array) {
		int x = array[0];
		System.out.println(x);
		return 0;
	}

	public static void main(String[] args) {
		int array[] = { 10, 5, 3, 4 };
		배열받아보자(array);
	}
```
문제 풀이

