## 1교시
1. 생성자는 함수다(특수함수)        
2. return이 없다(void도 없음)
3. 함수이름은 클래스이름과 동일!     
4. 기본 생성자(디폴트 생성자) 존재      
5. 생성자를 사용하는 이유?      
    => 필드변수에 값을 대입하기 위해서      

필드변수는 클래스 안에 있는 모든 메소드에서 사용 가능하다      
변수 옆에 this가 있으면 무조건 전역변수임     

Pizza p = new Pizza();      
1. Pizza 클래스를 외부에서 호출하려면 강제로 생성자를 사용해야 함       
2. 필드변수 값을 대입해 줌(생성자의 목적)       
    but, 사용빈도수 낮음       
3. get, set 함수 만들어서 대입하는 걸로 씀      

클래스는 필드변수(특성)와 메소드(행동)로 구성된다!      

## 2교시
```java
public class Pizza {
	String 피자종류;
	int 피자조각;
}

public class 생성자연습1 {
	public static void test(Pizza p) {
		p.피자조각 = 8;
		p.피자종류 = "치즈피자";
		p1 = new Pizza(); // 방법 3으로 null을 사용하면 메소드에서 만들어 줘야 함!
	}

	public static void main(String[] args) {
		// 방법 1. 클래스를 호출해서 변수에 담는다.
		Pizza p = new Pizza();
		test(p);// 실행시키려면 main 안에 작성해야 함

		// 방법 2. 클래스를 변수에 담지 않고 바로 넣는다.(잘 안 씀)
		// 이유 ) 디버깅이 안 됨!
		test(new Pizza());

		// 방법 3. null 데이터 넘겨주기
		Pizza p1 = null;
		// 클래스 타입은 초기값으로 null을 넣을 수 있다
		// 파일을 나중에 호출하고 싶을 때 null을 사용
		p1 = new Pizza();
	}
}
```

## 3교시
```
1)
boolean isTrue = false;
데이터 타입 : boolean
변수 명 : isTrue
연산자 :  =
데이터 : false

2)
Pizza p = new Pizza();
데이터 타입 : Pizza
변수 명 : p
연산자 : = 
생성자 : Pizza() 
//수정) Pizza() or 기본생성자

3) 
Pizza p = new Pizza("치즈피자");
데이터 타입 : Pizza
변수 명 : p
연산자 : =
생성자 : Pizza("치즈피자") 
// 수정) Pizza("치즈피자") or String을 받는 생성자

4) // 데이터와 생성자가 null인지 없음인지
Pizza p = null;
데이터 타입 :  Pizza
변수 명 : p
연산자 : =
데이터 : null
생성자 : 없음

5) 
new Pizza();
데이터 타입 : 없음
변수 명 : 없음
연산자 : 없음
생성자 : Pizza()

6) 
Pizza p = new Pizza();
Pizza p2 = new Pizza();
데이터 타입 : ex) Pizza, Pizza
변수 명 : p, p2
연산자 : =, =
생성자 : Pizza(), Pizza()

7) 
Pizza p = new Pizza();
p.피자종류 = "치즈피자";
Pizza p2 = new Pizza();
p2.피자종류 = "불고기피자";

p2.피자종류 값은? ( )
답 : 불고기피자

8) // 답이 존재하는지
Pizza p = null;
p.피자종류 = "치즈피자";
p.피자종류 값은? 
답 : 치즈피자 
// 수정) 오류 남!! 피자파일을 호출해야 피자파일 안에 있는 필드변수(메소드) 사용 가능!!
메인 또는 메소드에 p = new Pizza(); 추가로 입력해 주면 됨!

9)
Pizza p = null;
if(p == null){
  p = new Pizza();
  p.피자종류 = "불고기피자"
}
p.피자종류 값은?
답 : 불고기피자

10)
Pizza p = new Pizza();
  p.피자종류 = "치즈피자";
if(p != null){
  p = new Pizza();
  p.피자종류 = "불고기피자";
}
p.피자종류 값은?
답 : 불고기피자

11) // 변수명은??
Pizza클래스 피자종류 필드변수는 String 타입이다.
p.피자종류 = "콤보피자"
데이터 타입 : String
변수 명 : p
//수정) p.피자종류

연산자 :  =
데이터 : "콤보피자"

12) 
Pizza p = new Pizza();
Pizza p2 = new Pizza();
p2.피자종류 = "불고기피자";
p.피자종류 = p2.피자종류;
p.피자종류 값은?
답 : 불고기피자
```

## 4교시
```java
	public static Pizza getPizza(Pizza p) {
		p.피자조각 = 8;
		p.피자종류 = "치즈피자";
		return p;
	}
	
	public static void main(String[] args) {
		Pizza p = new Pizza();
		// 첫번째 방법
		p = getPizza(p);
		System.out.println("피자 조각 : "+p.피자조각);
		System.out.println("피자 종류 : "+p.피자종류);
		// 두번째 방법
		Pizza p2 = getPizza(p); // p2는 new로 부른적이 없는데 부를 수 있는 이유?
		// 파라미터로 new로 불러 온 클래스를 넣었기 때문에 클래스 리턴이 가능하다!
		p2.피자조각 = 1;
		p2.피자종류 = "포테이토피자";
		System.out.println("피자 조각 : "+p2.피자조각);
		System.out.println("피자 종류 : "+p2.피자종류);
		// 메소드로 클래스 리턴이 가능하다~!
		// 메소드 파라미터에 클래스타입이 있다면 new를 이용해서 클래스를 불러온 후 파라미터에 넣어야 함
	}
```

## 5교시
```java
    public class Pizza{
        String 피자종류;
        int 피자조각;
    }
    public static Pizza getPizza(Pizza p){
        //..소스 코드 작성
        return null;
    }
```
```java

    public static Pizza getPizza(){
         //..소스 코드 작성
        return null;
    }

    //메인메소드에서 Pizza를 호출했다고 가정하면..!
    public static void main(String[] args) {
        //getPizza피자 메소드 2개를 이용하자.
        Pizza p = new Pizza();
        //p2, p3로 Pizza 데이터 받기
        Pizza p2 = getPizza(p); 
        Pizza p3 = getPizza();

        System.out.println("p2 피자 종류 "+p2.피자종류);
        System.out.println("p2 피자 조각 "+p2.피자조각);
        System.out.println("p3 피자 종류 "+p3.피자종류);
        System.out.println("p3 피자 조각 "+p3.피자조각);
    }
```
위 코드 완성하기
```java
처음 푼 풀이
: 생성자를 하나만 사용해서 p2와 p3 값을 모두 받으려고 했고, p2를 출력할 때 p3로 대입한 변수 아래에서 출력하게 되면 처음 지정했던 p값이 아니라 p2임에도 나중에 지정한 p3값으로 출력됐기 때문에 프린트 위치를 위로 올려줬다.

	public static Pizza getPizza(Pizza p) {
		p.피자조각 = 20;
		p.피자종류 = "치즈피자";
		return p;
	}
	// 메인메소드에서 Pizza를 호출했다고 가정하면..!
	public static void main(String[] args) {
		// getPizza피자 메소드 2개를 이용하자.
		Pizza p = new Pizza();
		// p2, p3로 Pizza 데이터 받기
		Pizza p2 = getPizza(p);
		Pizza p3 = getPizza(p);
		// 바로 위 코드를 Pizza p3 = getPizza(new Pizza()); 로 바꾸면 
		// 프린트 위치에 상관없이 정상출력 된다!
		
		// getPizza(new Pizza()); 의 의미
		//   Pizza p = new Pizza();
		//   getPizza(p);
		// 바로 위 두 줄의 코드와 같다!
		
		// 즉 Pizza p3 = getPizza(new Pizza());는
		// Pizza p3 = new Pizza();
		// getPizza(p3);
		// 로 새 생성자를 만들어준 것과 같다
		p3.피자조각 = 100;
		p3.피자종류 = "불고기피자";
		// p2 출력 위치를 지정한 p3 값 아래로 내리면 p3의 값이 나오는 이유??
		//   p3이름으로 값을 지정해 주지만, 해당 코드로 p의 값 전체가 바뀌기 때문에 
		//   p3뿐만 아니라 p2의 이름으로 출력하는 것까지 같이 바뀌게 된다.
		System.out.println("p2 피자 조각 " + p2.피자조각);
		System.out.println("p2 피자 종류 " + p2.피자종류);
		System.out.println("p3 피자 종류 " + p3.피자종류);
		System.out.println("p3 피자 조각 " + p3.피자조각);
	}
```
```java
수정한 풀이
: p2는 파라미터 p의 함수를  받고, p3는 파라미터가 없는 함수를 받았다.

	public static Pizza getPizza(Pizza p) {
		p.피자조각 = 20;
		p.피자종류 = "치즈피자";
		return p;
	}

	public static Pizza getPizza() {
		Pizza p = new Pizza();
		p.피자조각 = 100;
		p.피자종류 = "불고기피자";
		return p;
	}

	// 메인메소드에서 Pizza를 호출했다고 가정하면..!
	public static void main(String[] args) {
		// getPizza피자 메소드 2개를 이용하자.
		Pizza p = new Pizza();
		// p2, p3로 Pizza 데이터 받기
		Pizza p2 = getPizza(p);
		Pizza p3 = getPizza();

		System.out.println("p2 피자 종류 " + p2.피자종류);
		System.out.println("p2 피자 조각 " + p2.피자조각);
		System.out.println("p3 피자 종류 " + p3.피자종류);
		System.out.println("p3 피자 조각 " + p3.피자조각);
	}
```

## 6교시
문제풀이

## 7교시
문제풀이
