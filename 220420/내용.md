```
상속(객체지향특징)
    상속을 하는 이유?
        마라토너 패키지 아래 3개의 클래스
        선수A 뛰다(),
        선수B 뛰다(),
        선수C 뛰다()
        
        ** 상속을 이용해서 뛰다()를 공통으로 처리

        운동기능{
            뛰다()
        }
        선수A extens 기능{
            뛰다() <- 부모 클래스에 있는 메소드 사용 가능
        }

    문제점
        자바에서 상속 한계 때문에 잘 쓰지 않음
            * 자바와 자바스크립트는 다중상속이 불가능 (C++은 다중상속 허용)
                선수들이 뛰다() 외에 공통적으로 갖는 급여를받다()를 상속으로 처리할 수 없다.
            => 다중상속을 받는 방법 필요!

    해결방법
        자바에서 제공하는 인터페이스를 사용하여 다중상속을 받은 것처럼 사용할 수 있다.
        인터페이스를 알기 위해 추상화라는 개념을 먼저 알아야 함
```

```
추상화 개념
    공통적으로 사용하는 기능을 따로 정의

추상 클래스, 추상 메소드
    추상클래스는 abstract 키워드로 선언된 클래스
    추상클래스에는 일반메소드, 추상메소드를 정의할 수 있다
    추상 => 공통 기능

    추상클래스의 한계
        클래스이기 때문에 다중상속 불가능
        => 그래서 인터페이스 사용한다
```
```java
package 추상;
abstract class Chef{
	// abstract가 붙으면 추상 클래스가 되고, 추상 메소드를 구현할 수 있음(일반 메소드도 가능)
	public void 요리를하다() {
		// 일반 메소드
	}
	abstract public void 비법을전수하다();
	// 추상메소드 
	// 로직구현이 목적이 아니어서 중괄호가 없다. 메소드만 정의하고 Chef를 상속받아서 오버라이딩하는게 목적! => 오버라이딩 필수!
	// 따라서 new로 호출(인스턴스화)이 불가능하다 (Chef c = new Chef 안 됨)
}

class Food extends Chef{
	// Food가 오버라이딩을 하면 Food클래스는 인스턴스화(호출)할 수 있다.
	// Food에 빨간 줄에 커서 올려놓고, add unimplemented method 추가 누르면 아래 메소드 자동입력됨
	@Override
	public void 비법을전수하다() {
		
	}
	// 원래는 오버라이딩 메소드를 사용이 optional이었지만 추상클래스의 추상메소드는 오버라이딩 메소드의 재정의가 필수!!
	// 추상메소드가 있는 추상클래스를 상속받으면 무조건 오버라이딩을 해야 함!!
}

public class 추상화를배우자 {
	public static void main(String[] args) {
		
	}
}
```

```
인터페이스
    데이터를 제공하는 규격 (공통기능을 제공함)
    다중상속 제공!
    인터페이스를 상속받으면 무조건 오버라이딩 해야 함

    클래스와 인터페이스는 다르기 때문에 패키지 아래 만들 때 인터페이스로 만들어야 함

    인터페이스 안에 있는 메소드는 모두 추상 메소드
    추상 메소드는 public이어야 함(가져다 쓰는게 목적이기 때문에 private 불가능)

```
```
    프로젝트를 할 때, 
        과장 : 테이블, 인터페이스 설계, 클라이언트 요구사항 정리
        대리 : 소스통합 & 배포
        사원 : 코드구현
```
```java
package 추상;
// 서비스를 제공해주는 기능
public interface ServiceImple {
	public abstract void 라면을끓이는방법();
	// 인터페이스 안의 메소드는 모두 추상메소드임. 따라서 public abstract는 생략 가능
	void 찌개끓이는방법();
}

package 추상;
public interface UserImple {
	void 요리를맛보다();
	void 요리를평가하다();
}

package 추상;
public class 백종원의요리교실 implements ServiceImple, UserImple{
// public class 백종원의요리교실 extends Object implements ServiceImple, UserImple{ }
// 위처럼 extends와 implements 같이 사용 가능(보통은 같이 안 씀)
	// implements를 이용하여 인터페이스 상속, 메소드 4개 받음(다중상속)
	// 오버라이딩 단축키 : alt + shift + s
	@Override
	public void 라면을끓이는방법() {
		
	}
	@Override
	public void 찌개끓이는방법() {
		
	}
	@Override
	public void 요리를맛보다() {
		
	}
	@Override
	public void 요리를평가하다() {
		
	}
	
	public static void main(String[] args) {
//		ServiceImple s = new ServiceImple(); <= ServiceImple의 목적에 어긋나서 오류남(인터페이스의 목적은 호출이 아니라 오버라이딩)
	}
}
```

```
ui/ux 요구분석
    카드 소팅 ==> 실무에선 하지 않음(하더라도 사용하는 툴이 따로 있음)
```

```
클래스를 파라미터로 받는 것 = "약한 결합(Loose Coupling)"
메소드에 클래스 직접 호출 = "강한 결합(Tight Coupling)"

결합이 약할수록 질 좋은 프래그래밍임
```

```
추상 클래스, 인터페이스는 인스턴스화(new 호출) 불가능
interface A

class B implements A
class C implements A
=> A가 부모 역할이 됨

A a = new A(); => 인터페이스라서 불가능
B b = new B(); 가능
C c = new C(); 가능

A = B
A = C

A a = new B();
A a = new C();
가 가능해진다.

UserServiceImple service = new UserService();
service = new UserService2(); 로 사용 가능 => 이 방법으로 실무에서 많이 사용한다!
(원래는 UserService2 service2 = new UserService2();)
```

```
누가 어떤 메소드를 만드었는지 추적해야 함
메소드 더블클릭 + alt + shift + j

리턴에 List<UserVO> 입력
=> 상속받은 메소드 위에 마우스를 올려 놓으면 날짜와 정보등이 나온다

이클립스 window -> preferences -> Java -> Code Style -> Code Templates -> Comments -> Methods -> edit -> apply and close
/**
 * ${tags}
 * @date : ${date}
 * @author : yyj or youngjoon yoo
 */

class는 types에 입력
/**
 * @author yyj
 * @Date : ${date}
 * comment :
 */

큰 프로젝트의 경우 버전을 표시하기도 함
 * version : 0.0.1v

class에서 alt+shift+j를 누르고 comment에 간단하게 남기기

메소드에는 잘 안 달고, 인터페이스와 클래스에 달아준다.
```