Static 
    목적 : 공유(share)
        ** static으로 선언된 메소드와 변수는 인스턴스화를 하지 않아도 호출이 가능하다.

    공유는 하는데 값이 변하지 않는 것들을 static으로 선언한다.
        ex) 진단코드, 질병코드
        public static final String GAMGI = "AA123";
        (final : 변하지 않는 상수)
        Code들을 하나의 클래스 파일에 선언하고 이곳저곳 공유함

변수
    static 변수
    non-static 변수

싱글톤 패턴
    코딩 디자인 패턴 중 하나
    싱글톤은 스태틱 개념을 응용함
    어플리케이션이 시작될 떄 어떤 클래스가 최초 한번만 메모리를 할당하고(static) 그 메모리에 인스턴스를 만들어 사용하는 디자인 패턴

    주로 공통된 객체(클래스)를 여러개 생성해서 사용하는 상황에서 많이 사용

    싱글톤은 여러차례 호출되더라도 실제로 생성되는 객체(클래스)는 하나이다.

    데이터베이스와 연동할 때 많이 사용

    Chef c = new Chef();
    각 클래스마다 위처럼 Chef를 새로 호출한다면 Heap 영역에 부하가 걸려서 다운될 것이다 
        해결방법 
        1. 좋은 슈퍼 컴퓨터
        2. 싱글톤(스태틱 메소드) 사용 => Heap에 공간 하나만 할당됨

    메소드 이름이 getInstance()면 싱글톤이라고 생각하면 됨.

static을 사용하는 경우
    ***1. 코드를 정의할 때
        단, 해당 클래스에는 변수만 존재!
    2. 객체를 여러개 생성해서 사용하는 상황일 때
        ex) 데이터베이스 연동할 때
        => 싱글톤으로 이미 구현되어 있어서 잘 사용하지 않음

```java
package 스태틱;
public class MainStatic {
	public static void main(String[] args) {
		StaticStudy s = new StaticStudy();
		System.out.println(s.COUNT); // 초기값 0
		s.COUNT++;
		System.out.println(s.COUNT); // 1
		
		StaticStudy s2 = new StaticStudy();
		System.out.println(s2.COUNT); // 1
		// => s2는 새로 호출한 것이라 원래 0이 나와야 하지만 static은 공유하기 때문에 s의 값을 가져온다.
		
		System.out.println(StaticStudy.COUNT); // 1
		// 인스턴트화하지 않고 호출함
		// static으로 선언된 메소드와 변수는 인스턴스화(new)를 하지 않아도 호출 가능
		// static 변수는 대문자여야함. 대문자에 기울어진 것들은 static이라고 생각하면 됨.
		
		Chef c = Chef.getInstance(); // 인스턴스화가 된 메소드를 스태틱으로 공유함
		c.printHello(); // 스태틱으로 선언한 메소드를 통해서 스태틱으로 선언되지 않은 메소드를 불러온다.  
		// 그렇다고 모든 변수를 스태틱으로 선언하면 스태틱 공간이 꽉 차기 때문에 일부만 스태틱으로 선언해서 나머지 변수를 불러온다.
        // Heap과 Static의 영역은 각각 별도로 존재하고 별도로 저장한다.
	}
}
```
```java
package 스태틱;
public class Chef {
	private static Chef chef = null;
	// private이라 공유할 수 없기 때문에 소문자
	public static Chef getInstance() { // 스태틱으로 선언된 메소드. 싱글톤 패턴.
		if(chef == null) {
			chef = new Chef();
		}
		return chef;
	}
	public void printHello() { // 스태틱으로 선언되지 않은 메소드
		System.out.println("Hellow World");
	}
}
```
```java
package test;
import java.util.ArrayList;
import java.util.List;

class Singer1{
	public String SingerName; //가수 이름
	public Singer1(String singerName) {
		this.SingerName = singerName;
	}
}

public class 긴급점검3 {
	public static List<Singer> getListSinger(ArrayList<Singer> list){
//		List<Singer> list = new ArrayList<Singer>();
////		Singer s = new Singer("김종국");
//		list.add(new Singer("김종국"));
//		list.add(new Singer("서인국"));
//		list.add(new Singer("방용국"));
//		// 타입이 Singer라서 list.add(); 괄호 안에도 타입에 맞게 new Singer()로 불러줌
//		for(Singer s : list) {
//			System.out.println(s.SingerName);			
//		}
		for(int i=0; i<list.size(); i++) {
			System.out.println(list.get(i).SingerName);
		}
		
		return list;
	}
	public static Singer getSinger(Singer s){
//		List<Singer> list = new ArrayList<Singer>();
//		list.add(new Singer("김종국"));
//		for(Singer s : list) {
//			System.out.println(s.SingerName);			
//		}
		System.out.println(s.SingerName);
		return s;
	}
	public static void main(String[] args) {
		ArrayList<Singer> list = new ArrayList<Singer>();
		list.add(new Singer("김종국"));
		list.add(new Singer("서인국"));
		list.add(new Singer("방용국"));
		//1. getListSinger()이용해서 김종국, 서인국, 방용국 list 출력!
		getListSinger(list);
		System.out.println("---");
		//2. getSinger()이용해서 김종국만 출력!
		Singer s = new Singer("김종국");
		getSinger(s);
	}
}
```
```java
package test;
import java.util.ArrayList;
import java.util.List;

class Singer{
	public String SingerName; //가수 이름
	public Singer(String singerName) {
		this.SingerName = singerName;
	}
}

public class 긴급점검33 {
	// 리턴타입이 뭔지 우선 확인하기
	public static List<Singer> getListSinger(){
		List<Singer> list = new ArrayList<Singer>();
		list.add(new Singer("김종국"));
		list.add(new Singer("서인국"));
		list.add(new Singer("방용국"));
		return list;
	}
	
	public static Singer getSinger(){
		String name = "";
		for(int i=0; i<getListSinger().size(); i++) {
			if(getListSinger().get(i).SingerName.equals("김종국")) {
				name = getListSinger().get(i).SingerName;
			}
		}
		// 방법1. s1
		Singer s1 = new Singer("김종국");
		// 방법2. s2
		Singer s2 = new Singer(name);
		return s2;
	}
	
	public static void main(String[] args) {
		//1. getListSinger()이용해서 김종국, 서인국, 방용국 list 출력!
		List<Singer> singer = getListSinger();
		for(int i=0; i<singer.size(); i++) {
			System.out.println(singer.get(i).SingerName);
		}
		//2. getSinger()이용해서 김종국만 출력!
		Singer s = getSinger();
		System.out.println(s.SingerName);
	}
}

```
```java
package test;
class eed{
	private String name;
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
}
public class 긴급점검4 {
	public static eed call() {
		eed e = new eed(); // 초기화
		return e;
	}
	public static void main(String[] args) {
		call().setName("아메리카노");
		String name = call().getName();
		System.out.println(name); // getName() 이전에 call()을 부름으로써 초기화됨
		eed e = call();
		e.setName("아메리카노");
		System.out.println(e.getName()); // 아메리카노
		// 함수를 바로 불러오는 것과 변수에 담아 불러오는 것은 차이가 있다!
	}
}

```