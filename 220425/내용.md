Static 
    목적 : 공유(share)
        ** static으로 선언된 메소드와 변수는 인스턴스화를 하지 않아도 호출이 가능하다.

    공유는 하는데 값이 변하지 않는 것들을 static으로 선언한다.
        ex) 진단코드, 질병코드
        public static final String GAMGI = "AA123";
        (final : 변하지 않는 상수)
        Code들을 하나의 클래스 파일에 선언하고 이곳저곳 공유함

변수
    static 변수
    non-static 변수

싱글톤 패턴
    코딩 디자인 패턴 중 하나
    싱글톤은 스태틱 개념을 응용함
    어플리케이션이 시작될 떄 어떤 클래스가 최초 한번만 메모리를 할당하고(static) 그 메모리에 인스턴스를 만들어 사용하는 디자인 패턴

    주로 공통된 객체(클래스)를 여러개 생성해서 사용하는 상황에서 많이 사용

    싱글톤은 여러차례 호출되더라도 실제로 생성되는 객체(클래스)는 하나이다.

    데이터베이스와 연동할 때 많이 사용

    Chef c = new Chef();
    각 클래스마다 위처럼 Chef를 새로 호출한다면 Heap 영역에 부하가 걸려서 다운될 것이다 
        해결방법 
        1. 좋은 슈퍼 컴퓨터
        2. 싱글톤(스태틱 메소드) 사용 => Heap에 공간 하나만 할당됨

    메소드 이름이 getInstance()면 싱글톤이라고 생각하면 됨.

static을 사용하는 경우
    ***1. 코드를 정의할 때
        단, 해당 클래스에는 변수만 존재!
    2. 객체를 여러개 생성해서 사용하는 상황일 때
        ex) 데이터베이스 연동할 때
        => 싱글톤으로 이미 구현되어 있어서 잘 사용하지 않음

```java
package 스태틱;
public class MainStatic {
	public static void main(String[] args) {
		StaticStudy s = new StaticStudy();
		System.out.println(s.COUNT); // 초기값 0
		s.COUNT++;
		System.out.println(s.COUNT); // 1
		
		StaticStudy s2 = new StaticStudy();
		System.out.println(s2.COUNT); // 1
		// => s2는 새로 호출한 것이라 원래 0이 나와야 하지만 static은 공유하기 때문에 s의 값을 가져온다.
		
		System.out.println(StaticStudy.COUNT); // 1
		// 인스턴트화하지 않고 호출함
		// static으로 선언된 메소드와 변수는 인스턴스화(new)를 하지 않아도 호출 가능
		// static 변수는 대문자여야함. 대문자에 기울어진 것들은 static이라고 생각하면 됨.
		
		Chef c = Chef.getInstance(); // 인스턴스화가 된 메소드를 스태틱으로 공유함
		c.printHello(); // 스태틱으로 선언한 메소드를 통해서 스태틱으로 선언되지 않은 메소드를 불러온다.  
		// 그렇다고 모든 변수를 스태틱으로 선언하면 스태틱 공간이 꽉 차기 때문에 일부만 스태틱으로 선언해서 나머지 변수를 불러온다.
        // Heap과 Static의 영역은 각각 별도로 존재하고 별도로 저장한다.
	}
}
```
```java
package 스태틱;
public class Chef {
	private static Chef chef = null;
	// private이라 공유할 수 없기 때문에 소문자
	public static Chef getInstance() { // 스태틱으로 선언된 메소드. 싱글톤 패턴.
		if(chef == null) {
			chef = new Chef();
		}
		return chef;
	}
	public void printHello() { // 스태틱으로 선언되지 않은 메소드
		System.out.println("Hellow World");
	}
}
```