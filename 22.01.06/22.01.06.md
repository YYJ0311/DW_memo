## <1교시>  
mysql 엔진이 c++로 만들어 졌기 때문에 선설치가 필요하다  
실무에 가더라도 설치하고 설정하는데 힘이 많이 듦  

데이터베이스 = 데이터를 저장하는 프로그램을 배우는 것!!  
우리는 sql이라는 문법을 사용해서 컴퓨터에 있는 DB의 데이터를 가져온다

- DDL, DML, DCL <==== 정처기 필기 단골 문제  
DDL(Data Definition Language) : CEATE, DROP, ALTER / 공통점 : table을 관리하는 명령어  
*****DML(Data Manipulation Language) : SELECT, DELETE, INSERT, UPDATE / 공통점 : table 안에 있는 데이터를 관리하는 명령어  
DCL(Data Control Language) : GRANT, REVOKE / 공통점 : 데이터베이스 관리

데이터베이스는 컴활에도 있다..  

DML
emp : 사원관리 테이블  
엔티티 = 테이블  
엔티티 관계도 = 테이블 관계도  
그릇이 table, 밥이 데이터  
테이블 안에 있는 각각의 것들이 컬럼(속성)  
컬럼 최상단에 열쇠모양 있는게 PK(Primary Key) = 고유데이터  

SELECT  
<컬럼 이름>,  
<컬럼 이름>,  
.  ,
.  ,
n  
  
FROM
<테이블 이름>  
  
WHERE  <== 필터링 기능  
<조건>  

## <2교시>  
MGR : 사수번호  
SAL : 월급  
COMM : 보너스(commission)  
DEPTNO : 부서번호  

Q. EMPNO가 7934인 사람의 직업과 고용날짜를 조회하세요  
select  
JOB,  
HIREDATE  
from emp  
where empno = 7934;  

Q. JOB이 CLERK인 사람의 이름과 고용날짜를 모두 조회  
hint) 문자 조회할 땐 "", '' 사용  
select  
ENAME,  
hiredate  
from emp  
where job="CLERK"  

where 옆에 컬럼명 = "데이터"  

Q. JOB이 MANAGER인 사람의 이름과 급여 조회  
select  
ename,  
sal  
from emp  
where job="manager"  

" = " : 관계 연산자  <== 코딩할 때 많이 사용  
### 관계 연산자의 종류  
>, <, <=, >=, =, !=(다르다를 의미)  

Q. 급여가 1000달러 이상인 사람의 이름과 직업 조회  
select  
ename,  
job  
from emp  
where sal >= 1000 ;  여기에서 "=>"로 표시하면 에러남  

count만 하고 싶은 경우
select  
count(*)  
from emp  
where sal >= 1000 ;  

아래 결과창에 별칭을 붙이고 싶을 때,  as 사용
select  
count(*) as '총합'  
from emp  
where sal >= 1000 ;  

Q. 87-06-28 이후에 입사한 사원을 조회  
select  
ENAME as '사원이름'   
from emp  
where HIREDATE >= '1987-06-28' ;  

Q. 입사한 날짜가 1982-01-23 이전에 입사한 사람의 이름과 직업, 부서번호를 조회  
select   
ename,  
job,  
DEPTNO   
from emp  
where HIREDATE <= '1982-01-23';  

### 논리 연산자 <=많이 쓸 예정!
and, or  
두 개가 참일 때 and 사용  
ex) 로그인할 때 ID와 비밀번호 모두 맞아야 로그인되게 만듦  
두 개중에 하나만 맞아도 되면 or 사용  

Q. 입사날짜가 1981-02-20부터 1981-12-03까지인 사람의 이름과 직업, 부서번호 조회  
select   
ename as '사원',  
job as '직업',  
DEPTNO as '부서'   
from emp  
where HIREDATE >= '1981-02-20' 
and 
HIREDATE <= '1981-12-03';  

## <3교시>  
정렬하기  
내림차순 : desc  
오름차순 : asc  

select   
ename,  
sal  
from emp  
order by SAL desc ;   

select   
ename,  
sal  
from emp  
order by SAL ;  
====> asc를 입력하지 않아도 오름차순으로 정렬된다. 오름차순이 디폴트값!  

정렬은 맨 뒤(where 뒤)에 온다.  

**컴퓨터 해석하는 순서  
from -> where -> select -> order by  
order by를 많이 쓰면 시스템에 부하가 간다.  

**null : 해당 데이터의 값이 아예 없는 상태  

Q. 커미션이 null인 사람 조회  
select   
ename,  
sal  
from emp  
where COMM is null  
order by sal ;  

Q. 커미션이 null이 아닌 사람 조회  
select   
ename,  
sal,  
COMM   
from emp  
where COMM is not null  

***실무에서 DB상에 수많은 데이터가 있기 때문에 null은 조회하지 않는다.  

Q. COMM이 null이 아닌 사원의 이름과 부서번호, 입사날짜를 오름차순으로 조회  
select   
ename,  
DEPTNO,  
HIREDATE   
from emp  
where COMM  is not null   
order by HIREDATE ;  

이름을 조회할 때  
select   
job  
from emp  
where ENAME = 'smith' ;  
하지만 관계연산자는 잘 사용 안 한다.  
따라서 다음으로  
select   
job  
from emp  
where ename like 'smith' ;  

**중복된 코드는 좋지않다!!  
ename 반복  
ex)  
select   
job  
from emp  
where ename = 'smith' 
or ename = 'allen';  

Q. 이름이 A로 시작하는 사람 조회  
like 'A%'를 사용한다.  
select   
ename,  
job  
from emp  
where ename like 'A%' ;  

Q. 이름에 L이 2번 들어간 사람 조회  
'%L%L%' 사용  

테이블에 데이터 추가  
insert into emp
(empno,ename,job,mgr,hiredate,sal,comm,deptno)  
values  
(8000,'유영준','salesman',7369,'2022-01-06',5000,1000,30)  

각각의 값들이 DB에 존재하지 않는다면 에러가 나온다.  
데이터를 입력하지 않으면 null로 표시된다.  
insert into emp  
(empno,ename,job,mgr,hiredate,sal,deptno)    
values    
(8001,'홍길동','salesman',7369,'2022-01-06',5000,30)   
===> 홍길동의 comm이 null로 표시됨  


## <4교시>  
update emp  
set ename = '정우성' --------->여기서 엔터 누르면 이름이 전부 정우성으로 바뀌게 돼버림!!! 주의!!!!  
where empno = 8001; <----------- 조건을 꼭!! 붙여줘야 한다!!  

update는 사실 mysql에서 해당 데이터를 delete 하고 insert 해 주는 것.  

Q. 우성이가 직업하고 월급 변경요청  
update emp  
set 
job = 'MANAGER',  
sal = 8000  
where empno = 8001;  

### 통계(count, sum, avg, max, min)  
select   
sum(comm) as '보너스 총 합'  
from emp  

select   
avg(comm) as '보너스 평균'  
from emp   

select   
max(sal) as '고액연봉액'  
from emp   

select   
min(sal) as '저액연봉액'  
from emp   

Q. 직업이 manager인 사람들의 급여 평균 조회  
select  
avg(sal) as'급여평균'  
from emp  
where job = "manager"  

Q. 입사날짜가 1987-06-25이상인 사람들의 수와 급여평균 조회  
select   
count(*),  
avg(sal)  
from emp  
where HIREDATE >= 1987-06-25  

Q. 직업이 CLERK인 사원 중 최소급여를 받고있는 사원의 이름과 입사날짜 조회  
select   
min(sal),  
ename,  
hiredate  
from emp  
where   
job = "CLERK"  

## <5교시>
Q. comm이 null이 아니고, 직업이 salesman 그리고 입사날짜가 1981-02-22이후에 들어온 사원의 comm 총합 조회  
select   
sum(comm)  
from emp  
where   
job = 'salesman'  
and   
HIREDATE >= 1981-02-22  
and   
COMM is not null   

그룹핑  
select
job  
from emp  
group by job  
having sum(sal) > 6000  

having은 그룹핑한 것들에 대한 필터링!!  
where과는 다르다!  

Q. 각 부서별(deptno) 그룹화하여 최고로 급여가 높은 사람의 이름과 직업을 조회  
select   
max(SAL),  
ename,  
job  
from emp  
group by DEPTNO   

Q. 직업이 세일즈맨인 사람을 제외하고 월급이 5000이 넘는 사람 조회
select   
max(SAL),  
ename,  
job  
from emp  
where JOB != 'salesman'  
group by DEPTNO   
having max(SAL) >= 5000  

group by는 where 다음에 나온다.  
group by를 할 때는 그룹이 나눠지는 것만 가능하다.  
(그룹화되지 않는 것도 결과가 나오지만 여러 데이터중 상단에 있는 데이터 하나만 가져오게 되므로 정상적인 결과가 아니다.)  
group by를 쓰면 select에는 그룹화되지 않는 컬럼을 쓰지 않는다.(ex. ename)  

*****연산순서  
from -> where -> group by -> having -> select -> order by  

## <6교시>
Q. 각 부서번호별 평균급여, 총 인원, 최고 급여, 최소 급여 조회  
select   
DEPTNO as 부서번호,   
count(*) as '총인원',  
avg(SAL) as '평균',  
max(SAL) as '최고급여',  
min(SAL) as '최소급여'  
from emp  
group by DEPTNO   

Q. 부서별 직책별 최대급여와 인원수, 최소급여를 추출  
단, 10번 부서와 사원은 제외하고, 인원수는 3명 이하인 것으로 인원수가 적은 순서대로 추출  

select   
DEPTNO,  
job,  
count(*),  
max(sal),  
min(sal)  
from emp  
where DEPTNO != 10  
group by   
DEPTNO,   
JOB   
having count(*) < 3  
order by   
count(*)  

Q. 부서별로 급여합계  
단, 10, 30번 부서와 급여합계가 5000이상인 부서만 추출  
select  
DEPTNO,   
sum(SAL)  
from emp  
where   
DEPTNO = 10  
or   
DEPTNO = 30  
group by DEPTNO   
having sum(SAL) > 5000  

Q. 직책별로 급여합계와 평균급여를 추출  
select   
JOB ,  
sum(SAL),  
avg(SAL)  
from emp  
group by JOB   

## <7교시>

