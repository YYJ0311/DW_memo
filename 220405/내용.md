
```java
package 상속;
// 클래스 이름 앞은 대문자!
public class Dw {
	String name; // 학생 이름
	String className; // 과정 이름
	int studentCount; // 학생 수
	// 필드변수는 값이 초기화(0 또는 null)가 되어 있다!
	
	// 1. 생성자에 파라미터 없이 필드변수 초기화 : getter, setter 사용
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
        // set은 return이 없다
	}
	public String getClassName() {
		return className;
	}
	public void setClassName(String className) {
		this.className = className;
	}
	public int getStudentCount() {
		return studentCount;
	}
	public void setStudentCount(int studentCount) {
		this.studentCount = studentCount;
	}
	
    // 2. 생성자 파라미터로 초기화
	public Dw(String name, String className, int studentCount) {
		// 생성자 이름(Dw)은 클래스 이름(Dw)과 동일해야 한다
		// 생성자 이름이 다르면 함수로 인식하기 때문에 return이 없으므로 오류가 나옴(void를 적으면 오류가 사라지고 일반 함수가 됨)
		this.name = name;
		this.className = className;
		this.studentCount = studentCount;
		// 생성자라서 return이 없음
	}
	public Dw() {
		
	}
}
```

```java
package 상속;
public class Home {
	public static void main(String[] args) {
		Dw dw = new Dw();
		// Dw클래스 파일에 public Dw(String name, String className, int studentCount) {} 생성자만 존재하는 경우 오류 발생
		// 오류해결방법 
		// 1. 파라미터에 값을 동일하게 3개 만듦
		// 2. Dw 클래스 파일에 파라미터가 없는 생성자를 하나 더 만듦 public Dw() {}
		// ** 오버로딩) 메소드 이름은 동일, 파라미터는 다르게
		
		// 파라미터 초기화 1. getter, setter 사용 
		dw.setName("홍길동");
		dw.setClassName("웹&앱반응형");
		dw.setStudentCount(13);
		
		String name = dw.getName();
		System.out.println("학생이름은 : "+name);
		String className = dw.getClassName();
		System.out.println("과정명 : "+className);
		int studentCount = dw.getStudentCount();
		System.out.println("학생 수 : "+studentCount);
		
		// 파라미터 초기화 2. 생성자 파라미터 타입과 개수를 맞춰서 입력
		// 2-1
		Dw dw2 = new Dw("홍길동","반응형개발",13); // 파일을 불러옴 = Dw를 "인스턴스화" 하다.
		System.out.println(dw2.name);
		System.out.println(dw2.className);
		System.out.println(dw2.studentCount);
		
		// 2-2
		Dw dw3 = null;
		if(dw3 == null) {
			dw3 = new Dw("김길동","멀티플랫폼개발",30);
			System.out.println(dw3.name);
			System.out.println(dw3.className);
			System.out.println(dw3.studentCount);
		}
		// 실무에서 많이 사용하는 방법. 클래스가 많다보니 null인지 체크해서 파일을 불러 옴
	}
}
```
---
---
```java
package 상속;
// 클래스 이름 : 붕어빵, 붕어빵 장사
// 붕어장사에 main
// 팥붕어빵 10개, 슈크림붕어빵 20개, 피자붕어빵 30개
// 조건) getter, setter 금지. 생성자 파라미터에 붕어빵종류, 수량(붕어빵 종류 = 팥, 수량 = 10)을 넣어서 만들기

public class 붕어빵 {
//	String 붕어빵종류;
//	int 붕어빵수;
//	public 붕어빵(String 붕어빵종류, int 붕어빵수) {
//		this.붕어빵종류 = 붕어빵종류;
//		this.붕어빵수 = 붕어빵수;
//	}
	String type;
	int count;
	public 붕어빵(String type, int count) {
		this.type = type;
		this.count = count;
	}
}
```
```java
package 상속;
public class 붕어빵장사 {
	public static void main(String[] args) {
//		붕어빵 빵 = new 붕어빵("팥",10);
//		System.out.println(빵.붕어빵종류+"붕어빵 "+빵.붕어빵수+" 개");
//		붕어빵 빵01 = new 붕어빵("슈크림",20);
//		System.out.println(빵01.붕어빵종류+"붕어빵 "+빵01.붕어빵수+" 개");
//		붕어빵 빵02 = new 붕어빵("피자",30);
//		System.out.println(빵02.붕어빵종류+"붕어빵 "+빵02.붕어빵수+" 개");
		
		붕어빵 팥붕어 = new 붕어빵("팥",10);
		System.out.println(팥붕어.type+"붕어빵 "+팥붕어.count);
		붕어빵 슈크림붕어 = new 붕어빵("슈크림",20);
		System.out.println(슈크림붕어.type+"붕어빵 "+슈크림붕어.count);
		붕어빵 피자붕어 = new 붕어빵("피자",30);
		System.out.println(피자붕어.type+"붕어빵 "+피자붕어.count);
		// 생성자로 호출과 동시에 각각의 값으로 초기화가 됨
	}
}
```

# 상속
```
중복된 행위들을 상속으로 묶음
공통행위를 하는 클래스를 따로 만든다
객체지향 프로그래밍에 존재함

상원 class
    <!-- 출근하다() -->
근환 class
    <!-- 출근하다() -->
인석 class
    <!-- 출근하다() -->

공통기능 class
    출근하다()
상원, 근환, 인석 클래스가 공통기능 클래스에서 출근하다 기능을 가져다 씀

공통기능 : 부모 클래스(또는 슈퍼 클래스)
상원, 근환, 인석 : 자식 클래스(또는 서브 클래스)

메소드와 필드변수를 제공하는 주체가 부모가 됨
1. 자식 클래스는 부모의 기능 (메소드, 필드변수)를 사용할 수 있다. 반대는 안 됨.
2. 모든 클래스의 부모는 Object다! (모든 클래스는 디폴트로 Object를 상속받고 있음)
3. 자바는 C++과 다르게 다중 상속이 없다. (부모는 1명이다)
```
```
문법
extends : 상속
class Pizza extends Object{
    <!-- 피자가 object를 상속하다 -->
    <!-- 부모가 Object, 자식이 Pizza -->
}
```

```java
package 상속;
class Student_C{
	public void 공부하다() {
	System.out.println("JAVA 공부 중...");
	}
}
class Student_B{
	public void 공부하다() {
	System.out.println("SQL 공부 중...");
	}
}
class Student_A{
	public void 공부하다() {
	System.out.println("HTML 공부 중...");
	}
}
public class School {
	public static void main(String[] args) {
	Student_C c = new Student_C();
	// new를 이용해서 해당 클래스를 불러 옴
	// new를 사용하는 순간 heap 영역으로 넘기겠다는 뜻
	// Student_C() : 생성자
	c.공부하다();
	Student_B b = new Student_B();
	b.공부하다();
	Student_A a = new Student_A();
	a.공부하다();
	}
}
```

```java

```