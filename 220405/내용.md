```
이클립스 사용
지금 사용하는 자바는 12버전 (대부분 1.8이나 11을 많이 씀. 버전이 높으면 아래 것을 사용할 수 있는데, 버전이 낮으면 위에 것을 쓸 수 없음)

1. java_start 프로젝트 생성(익스플로러 탭에서 오른쪽 클릭 - new - 모듈생성 don't create - open perspective)
    프로젝트 이름은 대문자 or 소문자(복합명사는 보통 언더바(_) 사용. main_file)
2. src 아래에 상속 패키지 생성 (생략가능)
    패키지 이름은 소문자 (복합명사는 카멜표기법 사용. mainFile)
3. 클래스 파일 생성
    앞글자를 대문자, main 체크하고 생성

new를 이용해서 클래스를 호출할 때 생성자가 자동으로 호출됨

자바 : 프로젝트 -> 패키지 -> 클래스
(이클립스에서 프로젝트를 만들면 패키지가 디폴트로 존재하기 때문에 바로 클래스 생성 가능)

상속
    클래스(객체)에 대한 개념이 부족하면 상속을 알기 힘듦
```
```java
package 상속;

class Pizza{
	int money; // 전역변수 또는 필드변수
	// 필드변수는 디폴트로 값이 초기화 되어있음(= 0 또는 = "null"이 들어있음)
	// int money = 0;
	public int getMoney() {
		return 0;
	}
	// 클래스파일을 만들면 디폴트 생성자가 만들어짐!
	// public Pizza() {} 라는 생성자가 디폴트로 만들어져 있다
	public Pizza() {
		// 만약 () 안에 파라미터를 입력할 경우, 아래에서 사용하는 Pizza의 괄호 안에도 같이 입력해야 된다.
		// Pizza(int x)라고 적은 경우 아래에는 Pizza(int x) 또는 Pizza(10)같이 파라미터를 입력해야 함
		this.money = 10;
		// this = Pizza
	}
	// * 생성자와 일반함수의 차이 : 생성자는 return을 정의하지 않는다.
	// 이유 : 생성자는 파라미터 값을 받아서 결과를 처리하고 return하는 게 아니라 값을 초기화하는게 목적이기 때문
} // end Pizza class

public class Study0405 {
// .java 파일에 public class가 2개 이상 올 수 없다(파일 이름임)
	public static void main(String[] args) {
		// System.out.println("hello world");
		// 작은 따옴표 쓰면 안 됨...
		Pizza p = new Pizza();
		// new는 자바 특징이 아니라 객체 지향 언어의 특징. JS에도 존재했음
		// () : 생성자(메소드), 정의하지 않은 생성자를 쓸 수 있는 이유는 디폴트로 존재하기 때문!
		// Pizza라는 클래스도 데이터타입
		// System.out.println(p.money);
		// 여기서 this = Study0405를 의미함
	}
}
```

```
데이터 타입
    정적 : Int, Double, Char, Float, 배열([])
    동적 : String, Class, 배열
        * Heap Area(동적을 관리하는 영역, Heap 메모리에 저장됨)
    컴퓨터 내부에서 정적타입과 동적타입을 관리하는 영역이 다르다

    (class 파일을 많이 만들어서 사용하다보면 Heap 영역에서 오류가 나게 됨(Heap에 더이상 저장 공간이 없으면 서버가 다운))

    Heap을 튜닝하는 건 시니어 개발자나 엔지니어의 몫
```
---
---
```java
package 상속;
// 클래스 이름 앞은 대문자!
public class Dw {
	String name; // 학생 이름
	String className; // 과정 이름
	int studentCount; // 학생 수
	// 필드변수는 값이 초기화(0 또는 null)가 되어 있다!
	
	// 1. 생성자에 파라미터 없이 필드변수 초기화 : getter, setter 사용
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
        // set은 return이 없다
	}
	public String getClassName() {
		return className;
	}
	public void setClassName(String className) {
		this.className = className;
	}
	public int getStudentCount() {
		return studentCount;
	}
	public void setStudentCount(int studentCount) {
		this.studentCount = studentCount;
	}
	
    // 2. 생성자 파라미터로 초기화
	public Dw(String name, String className, int studentCount) {
		// 생성자 이름(Dw)은 클래스 이름(Dw)과 동일해야 한다
		// 생성자 이름이 다르면 함수로 인식하기 때문에 return이 없으므로 오류가 나옴(void를 적으면 오류가 사라지고 일반 함수가 됨)
		this.name = name;
		this.className = className;
		this.studentCount = studentCount;
		// 생성자라서 return이 없음
	}
	public Dw() {
		
	}
}
```

```java
package 상속;
public class Home {
	public static void main(String[] args) {
		Dw dw = new Dw();
		// Dw클래스 파일에 public Dw(String name, String className, int studentCount) {} 생성자만 존재하는 경우 오류 발생
		// 오류해결방법 
		// 1. 파라미터에 값을 동일하게 3개 만듦
		// 2. Dw 클래스 파일에 파라미터가 없는 생성자를 하나 더 만듦 public Dw() {}
		// ** 오버로딩) 메소드 이름은 동일, 파라미터는 다르게
		
		// 파라미터 초기화 1. getter, setter 사용 
		dw.setName("홍길동");
		dw.setClassName("웹&앱반응형");
		dw.setStudentCount(13);
		
		String name = dw.getName();
		System.out.println("학생이름은 : "+name);
		String className = dw.getClassName();
		System.out.println("과정명 : "+className);
		int studentCount = dw.getStudentCount();
		System.out.println("학생 수 : "+studentCount);
		
		// 파라미터 초기화 2. 생성자 파라미터 타입과 개수를 맞춰서 입력
		// 2-1
		Dw dw2 = new Dw("홍길동","반응형개발",13); // 파일을 불러옴 = Dw를 "인스턴스화" 하다.
		System.out.println(dw2.name);
		System.out.println(dw2.className);
		System.out.println(dw2.studentCount);
		
		// 2-2
		Dw dw3 = null;
		if(dw3 == null) {
			dw3 = new Dw("김길동","멀티플랫폼개발",30);
			System.out.println(dw3.name);
			System.out.println(dw3.className);
			System.out.println(dw3.studentCount);
		}
		// 실무에서 많이 사용하는 방법. 클래스가 많다보니 null인지 체크해서 파일을 불러 옴
	}
}
```
---
---
```java
package 상속;
// 클래스 이름 : 붕어빵, 붕어빵 장사
// 붕어장사에 main
// 팥붕어빵 10개, 슈크림붕어빵 20개, 피자붕어빵 30개
// 조건) getter, setter 금지. 생성자 파라미터에 붕어빵종류, 수량(붕어빵 종류 = 팥, 수량 = 10)을 넣어서 만들기

public class 붕어빵 {
//	String 붕어빵종류;
//	int 붕어빵수;
//	public 붕어빵(String 붕어빵종류, int 붕어빵수) {
//		this.붕어빵종류 = 붕어빵종류;
//		this.붕어빵수 = 붕어빵수;
//	}
	String type;
	int count;
	public 붕어빵(String type, int count) {
		this.type = type;
		this.count = count;
	}
}
```
```java
package 상속;
public class 붕어빵장사 {
	public static void main(String[] args) {
//		붕어빵 빵 = new 붕어빵("팥",10);
//		System.out.println(빵.붕어빵종류+"붕어빵 "+빵.붕어빵수+" 개");
//		붕어빵 빵01 = new 붕어빵("슈크림",20);
//		System.out.println(빵01.붕어빵종류+"붕어빵 "+빵01.붕어빵수+" 개");
//		붕어빵 빵02 = new 붕어빵("피자",30);
//		System.out.println(빵02.붕어빵종류+"붕어빵 "+빵02.붕어빵수+" 개");
		
		붕어빵 팥붕어 = new 붕어빵("팥",10);
		System.out.println(팥붕어.type+"붕어빵 "+팥붕어.count);
		붕어빵 슈크림붕어 = new 붕어빵("슈크림",20);
		System.out.println(슈크림붕어.type+"붕어빵 "+슈크림붕어.count);
		붕어빵 피자붕어 = new 붕어빵("피자",30);
		System.out.println(피자붕어.type+"붕어빵 "+피자붕어.count);
		// 생성자로 호출과 동시에 각각의 값으로 초기화가 됨
	}
}
```

# 상속
```
중복된 행위들을 상속으로 묶음
공통행위를 하는 클래스를 따로 만든다
객체지향 프로그래밍에 존재함

상원 class
    <!-- 출근하다() -->
근환 class
    <!-- 출근하다() -->
인석 class
    <!-- 출근하다() -->

공통기능 class
    출근하다()
상원, 근환, 인석 클래스가 공통기능 클래스에서 출근하다 기능을 가져다 씀

공통기능 : 부모 클래스(또는 슈퍼 클래스)
상원, 근환, 인석 : 자식 클래스(또는 서브 클래스)

메소드와 필드변수를 제공하는 주체가 부모가 됨
1. 자식 클래스는 부모의 기능 (메소드, 필드변수)를 사용할 수 있다. 반대는 안 됨.
2. 모든 클래스의 부모는 Object다! (모든 클래스는 디폴트로 Object를 상속받고 있음)
3. 자바는 C++과 다르게 다중 상속이 없다. (부모는 1명이다)
```
```
문법
extends : 상속
class Pizza extends Object{
    <!-- 피자가 object를 상속하다 -->
    <!-- 부모가 Object, 자식이 Pizza -->
}
```
```java
package 상속;
class Student_C{
	public void 공부하다() {
	System.out.println("JAVA 공부 중...");
	}
}
class Student_B{
	public void 공부하다() {
	System.out.println("SQL 공부 중...");
	}
}
class Student_A{
	public void 공부하다() {
	System.out.println("HTML 공부 중...");
	}
}
public class School {
	public static void main(String[] args) {
	Student_C c = new Student_C();
	c.공부하다();
	Student_B b = new Student_B();
	b.공부하다();
	Student_A a = new Student_A();
	a.공부하다();
	}
}
```
