하루에 최소 30분 이상씩 공부하자!       

## 1교시
기본으로 외우기 
```html 
    - 링크태그
    <a href="주소적기"> 설명 </a>

    - 대/중/소 제목태그
    <h1 ~ 6></h1 ~ 6>

    - 입력 text 태그
    <input type="text" placeholder="텍스트 설명"/>

    - 입력 비밀번호 태그
    <input type="password" placeholder="비번 최대 2글자" maxlength="2"/>

    - 버튼 태그 
    1. <input type="button" value="버튼 내용" />
    2. <button>버튼 내용</button>

    - 테이블 태그(ex. 게시판)     

    <table> 
        <thead> <!--테이블제목(컬럼)-->
            <tr> <!--줄 구분-->
                <th>이름</th>
                <th>나이</th>
                <th colspan="2">내용</th> <!--옆으로 확장-->
            </tr>
        </thead>
        <tbody> <!--제목(컬럼)에 해당하는 데이터-->
            <tr>
                <td>홍길동</td>
                <td>30</td>
                <td rowspan="2">내용</td> <!-- 밑으로 확장-->
            </tr>
        </tbody>
    </table>
```

## 2교시
- ul : Unorder List (정렬되지 않은 리스트)
li : List Item
<ul>
    <li>
        <a href="이동할 주소"></a>상의
    </li>
    <li>하의</li>
    <li>신발</li>
    <li>모자</li>
</ul>

ol : Order List (앞에 번호가 붙음)
<ol>
    <li>JAVA</li>
    <li>Python</li>
    <li>HTML</li>
    <li>SQL</li>
</ol>

div 태그는 공간(구역)을 의미함

태그 만들 때 *개수 입력하면 그만큼 만들어짐!      
ex. div*3

페이지에서 f12 누르고 휴대폰모양(togle device toolbar) 버튼을 눌러 각 휴대폰별로 보여지는 화면을 확인할 수 있다!

## 3교시
태그마다 position을 가지고 있음.        
position 디폴트값이 static.     
1. static(디폴트) : 위치를 지정하지 않을 때     
2. relative : 원래 자리 기준으로 움직임.        
3. absoulute        
4. fixed        

태그를 움직이려면 상태를 ralative로 바꿔줘야 한다!      

- SQL
JOIN : 교집합 데이터를 연결!        
       2개 이상 테이블 데이터를 조회할 때       
```sql
교집합 조인(내부조인)
SELECT
    e.ename
FROM emp AS e
INNER JOIN dept AS d
ON e.deptno = d.deptno
```
```sql
아우터조인
-- emp에 없는 deptno까지 조회하시오.
SELECT
    *
FROM emp as e
RIGHT JOIN dept as d
ON e.deptno = d.deptono
```

SQL 프로그래머스 문제풀이

## 4교시
SQL 프로그래머스 문제풀이

복습

## 5교시
- 서브쿼리        
    : 하나의 쿼리에 또 쿼리가 옴        
    1. SELECT 절에 오는 서브쿼리 (스칼라 서브쿼리)
    2. WHERE 절에 오는 서브쿼리 (중첩 서브쿼리)
    3. FROM 절에 오는 서브쿼리 (인라인 뷰)

- 서브쿼리가 가능한 곳      
    1. ***SELECT
    ```sql
        A 테이블(감기 관련),
        B 테이블(코로나 확진자 관련),
        C 테이블(오미크론 확진자 관련)

        조건. 교집합 데이터(컬럼)이 없음.
        실행. 서브쿼리가 먼저 실행된 후 외부쿼리가 실행된다.
        SELECT
            COUNT(*) AS 감기확진,
            (SELECT COUNT(*) FROM 코로나) AS 코로나확진, // 서브쿼리 먼저 실행됨
            (SELECT COUNT(*) FROM 오미크론) AS 오미크론확진 // 서브쿼리 먼저 실행됨
        FROM 감기

        ===> 이런 경우 테이블이 교집합이 존재하지 않은 상태(엉망인 상태)인 경우이므로 쓸일이 많진 않다.
    ```
    2. ***FROM (제일 많이 씀!!)
    ```sql
        언제. 데이터를 먼저 필터링 해야할 때
        ex) emp 테이블에 급여가 3천 미만인 사람 데이터로 뭔가를 활용할 때
        select
            e.ename,
            e.job
        from (
            select
            ename,
            job
            from emp
            where sal < 3000
        ) as e
        group by e.job
    ```
    3. ***WHERE
    ----------
    4. HAVING 
    5. ORDER BY
    6. INSERT
    7. UPDATE set

- 서브쿼리를 쓰기 전에 한번 생각하기! (정말 필요한가?)       

## 6교시
- where 서브쿼리        
    1. 단일행
        : 서브쿼리의 결과가 하나의 행으로 나옴
    ```sql
    SELECT 
        *
    FROM emp
    WHERE ename = (
        SELECT
            ename
        FROM emp
        WHERE
            empno = 3000)
    ```

    2. 다중행
        : 서브쿼리의 결과가 여러 행으로 나옴
    ```sql
    IN : 실제로 존재하는 데이터의 값을 비교
    (IN을 사용하게 되면 비교뿐만 아니라 그 데이터가 테이블에 존재하는지도 체크해야 함.)
    => 데이터가 많아질수록 속도가 느려짐

    웬만하면 IN 서브쿼리(WHERE 서브쿼리)를 쓰지 않는 게 손실이 적다!(속도가 빠르다!)
    => 따라서 from에 서브쿼리를 많이 씀

    SELECT
        *
    FROM emp
    WHERE
       ename IN (
            SELECT
                ename
            FROM emp
            WHERE
                sal<3000)
    ```

- IN 대신 EXISTS를 사용 (괄호안이 true면 실행O, false면 실행X) : 자바의 플래그와 비슷
    ```sql
    SELECT
        ename,
        job
    FROM emp
    WHERE exists (
        SELECT
            *
        FROM emp
        WHERE
            deptno = 40
        )
    ===> deptno = 40이 false이므로 결과값 없음
    ```

## 7교시
복습

- 프로그래머스 서브쿼리 문제
테이블 PLACES는 공간 임대 서비스에 등록된 공간의 정보를 담은 테이블이다.        
그리고 ID는 공간의 아이디, NAME은 공간의 이름, HOST_ID는 공간을 소유한 유저의 아이디를 나타내는 컬럼들이다.     
Q. 공간을 둘 이상 등록한 사람을 헤비유저라고 할 때, 헤비유저가 등록한 공간의 정보를 아이디 순으로 조회하는 방법은?
정답)
```sql
SELECT
    p.ID,
    p.NAME,
    r.HOST_ID
FROM (
    SELECT
        HOST_ID,
        COUNT(*) AS cnt
    FROM PLACES
    GROUP BY HOST_ID
    HAVING COUNT(*) >= 2
    ) AS r
INNER JOIN PLACES as p
on r.HOST_ID = p.HOST_ID 
ORDER BY p.ID ASC
```
주석처리
```sql
SELECT
    p.ID,
    p.NAME,
    r.HOST_ID -- r로 묶었던 것들의 HOST_ID 표시
FROM(
    SELECT
        HOST_ID,
        COUNT(*) AS cnt -- HOST_ID로 그룹핑한 각각의 개수를 cnt라고 지정
    FROM PLACES
    GROUP BY HOST_ID
    HAVING COUNT(*) >= 2 -- 그룹핑한 것의 개수가 2개 이상이어야 함
    ) AS r -- HOST_ID가 2개 이상인 것들을 r로 지정
-- 그리고 이 상태로는 ID와 NAME을 조회할 수 없기 때문에 자기 자신과 inner join을 해 준다.
INNER JOIN PLACES as p
on r.HOST_ID = p.HOST_ID
ORDER BY p.ID ASC
```
ㅡㅡㅡㅡㅡㅡㅡㅡ
내일 시험 

테이블만들기 안보고
form 만들기 2개 보면서 가능
