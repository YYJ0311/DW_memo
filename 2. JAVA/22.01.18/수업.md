## 1교시
- <접근지정자><리턴타입><메소드이름>(파라미터)        
- DB를 연동했을 때를 생각해보면     
```
select 
        ename,
from emp
where empno = 번호 
```
사원의 이름을 구할 때,      
파라미터에는 where절에 오는 empno       
리턴타입에는 select절에 오는 데이터 타입 string이 올 것임       

- 메소드 오버로딩(overloading)      
```
	// 메소드 오버로딩(overloading) <== 오버라이딩이랑 구분하기!
	// 메소드 이름은 같은데 인자값이 다르면 오류가 사라진다.
	// 메소드 오버로딩의 목적 : 이름이 같은 여러개의 메소드를 중복 선언하여 사용의 편리성을 제공
	// 조건 : 1. 이름이 동일해야 함.
	// 2. 인자의 개수가 달라야 함.
	// 3. 인자의 타입이 달라야 함.
	// 4. 동일한 클래스 파일 안에 있어야 함.
	// 리턴타입은 신경 안 씀.
	// 결론 : 파라미터가 중요하다!
	public int getSum(int x, int y) {
		return 0;
	}

	public int getSum(int x, int y, int z) { // 인자의 개수가 다름
		return 0;
	}

	public int getSum(int x, String y) { // 인자의 타입이 다름
		return 0;
	}

	public static void main(String[] args) {
	}
```
- 클래스 ?(책 133p)     
자바는 <객체 지향 언어>       
요새 패러다임은 객체지향언어!  
클래스(객체)들이 모여서 하나의 프로그램이 탄생함        
마우스, 키보드, 모니터, 본체, 스피커, ... => 컴퓨터를 하게 됨!      

### 객체지향언어 특징(면접 나옴!!) 자바 특징이 아님!     
    1. 캡슐화       
    - 내부를 마치 캡슐처럼 보호
      (클래스가 메소드를 담고 있음)
    2. 상속  
    - 클래스를 부모와 자식으로 두고 부모의 기능을 물려받음
    3. 다형성
    - 같은 이름의 메소드가 다르게 구현
      (메소드 오버로딩, 오버라이딩)

클래스 파일 안에 클래스를 여러개 만들 수 있지만, 퍼블릭 클래스는 해당 클래스 파일에 한번만 올 수 있다.(퍼블릭 클래스는 고유함)

## 2교시
```
// Pizza 클래스 생성

// 피자라는 객체(==Object) 생성
public class Pizza {
	public void 도우를만들다() {
		System.out.println("도우 만드는 중~");
	}

	public void 토핑을추가하다(String 토핑) {
		System.out.println(토핑 + " 토핑 추가!");
	}
	
	private void 비법소스를첨가하다() { // private
		System.out.println("최고급 트러플 오일 듬뿍!");
	}

	public void 피자를굽다() {
		System.out.println("피자 굽는 중~");
	}

}// 캡슐화

}// 캡슐화
```
```
// Client 클래스 main으로 생성

public class Client {
	public static void main(String[] args) {
		// 피자 객체(오브젝트) 호출
		int x = 10; // 데이터타입 : int , 변수 : x
		Pizza 하와이안피자_치즈듬뿍 = new Pizza(); // new : 클래스 호출
		// Pizza를 객체(==인스턴스)화 했다 == Pizza 클래스 호출
		// 데이터타입 : Pizza(클래스), 변수 : 하와이안피자_치즈듬뿍
		하와이안피자_치즈듬뿍.도우를만들다();
		하와이안피자_치즈듬뿍.토핑을추가하다("버섯");
		하와이안피자_치즈듬뿍.피자를굽다();

		// 불고기피자 제작 과정
		Pizza 불고기피자 = new Pizza();
		불고기피자.도우를만들다();
		불고기피자.토핑을추가하다("페퍼로니");
		// 불고기피자.비법소스를첨가하다(); 는 private이라 호출되지 않는다.
		// 메소드에 접근지정자를 private로 선언하면 외부 클래스에서 호출시 해당 메소드를 호출할 수 없다.
		불고기피자.피자를굽다();
	}
}
```

## 3교시
```
public class Hamburger {
	public void 빵굽다() {
		System.out.println("빵 굽는중~");
	}

	public String 패티추가하다(String 패티이름) { // void가 아니라서 return을 써야 한다!!
		return 패티이름;
	}

	public int 주문수량(int 주문수량) { // void가 아니라서 return을 써야 한다!!
		return 주문수량;
	}
}
```
```
public class Client2 {
	public static void main(String[] args) {
		Hamburger 불고기버거 = new Hamburger();
		불고기버거.빵굽다();
		String 패티1 = 불고기버거.패티추가하다("불고기");
		System.out.println(패티1 + " 패티 추가");
		int 수량1 = 불고기버거.주문수량(5);
		System.out.println(수량1 + "개 주문");

		Hamburger 치즈버거 = new Hamburger();
		치즈버거.빵굽다();
		String 패티2 = 치즈버거.패티추가하다("치즈");
		System.out.println(패티2 + " 패티 추가");
		int 수량2 = 치즈버거.주문수량(3);
		System.out.println(수량2 + "개 주문");
	}
}
```
- 문자메소드        
```
		String name = "abCD";
		//name.하면 나오는 것들은 전부 String 메소드들
		//대문자 -> 소문자 변환
		String result1 = name.toLowerCase();//toLowerCase 함수 두개가 가능한 이유 : 오버로딩
		System.out.println(result1);
		//소문자 -> 대문자 변환
		String result2 = name.toUpperCase();
		System.out.println(result2);
		//*****공백제거! 진짜 많이 씀!! 
		String id = " 홍길동";
		String result3 = id.trim(); 
		System.out.println(result3);
		//*****
		String phone = "010-1234-1234";
		String array[] = phone.split("-");//split은 문자배열로 인식
		System.out.println(array[0]);
		System.out.println(array[1]);
```

## 4교시
```
		String 닉네임 = "Zi존도적xx";
		int len = 닉네임.length();
		System.out.println(result4);
		if(len > 4) {
			System.out.println("닉네임은 4글자 이하로만 작성 가능합니다.");
		}

		//****특수문자 제거
		String password = "123@";
		result1 = password.replace("@", "");//왼쪽이 바꿀 대상, 오른쪽이 바꾸고자 하는 문자
		System.out.println(result1);


		//*****문자 중간에 공백 제거
		String password2 = " 123 123 123 "; //trim으로는 문자 중간에 오는 공백을 제거할 수 없다.
		result1 = password2.replace(" ", "");
		System.out.println(result1);
```

## 5교시
```
	//조건 1. 아이디 길이가 10이하, 2이상
	//조건 2. 아이디를 대문자에서 소문자로 변경.
	//조건 3. 아이디에 '!'가 들어가면 안됨.
	//조건 4. 아이디에 문자 공백이 들어가면 안됨.
	public static String getResult(String id) {
		id = id.toLowerCase(); // 조건 하나씩 달성
		id = id.replace("!", ""); // 조건 하나씩 달성
		id = id.replace(" ", ""); // 조건 하나씩 달성
		return id;
	}

	public static void main(String[] args) {
		String userID = "J a!va! ";
		String id = getResult(userID);
		int a = id.length();
		if(a<=10 && a>=2) {
			System.out.println(id);
		}else {
			System.out.println("아이디는 10자 이하 2자 이상으로만 작성 가능합니다.");
		}
	}
```
```
선생님 풀이보고 수정한 것
if 조건을 최상위로 올렸고, 해당되지 않는 조건을 메소드에서 공백으로 출력되게 바꿈.
	public static String getResult(String id) {
		int len = id.length();
		if (len <= 10 && len >= 2) {
			id = id.toLowerCase(); // 조건 하나씩 달성
			id = id.replace("!", ""); // 조건 하나씩 달성
			id = id.replace(" ", ""); // 조건 하나씩 달성
			return id; // 조건을 만족하는 id값 main으로 반환
		} else {
			System.out.println("아이디는 10자 이하 2자 이상으로만 작성 가능합니다.");
			return ""; // 조건 이외의 값은 공백 & 에러 메세지 출력
		}
	}

	public static void main(String[] args) {
		String userID = "J a!va! dsfsad";
		String id = getResult(userID); // 메소드와 연결
		System.out.println(id); // 메소드 값 출력
	}
```
```
선생님 풀이
	public static String getResult(String id) {
		String temp = ""; // temp를 사용한 것이 내 풀이와 차이점
		if(id.length() <= 10 && id.length() >=2){
			temp = id.toLowerCase();
			temp = temp.replace("!","");
			temp = temp.replace(" ","");//가운데 문자열 공백제거는 trim으로 불가능
			return temp.trim();
		}
		return temp;
	}
	public static void main(String[] args) {
		String userID = "J a!va! ";
		String id = getResult(userID);
		System.out.println(id);
	}
```

- main 함수에는 static 함수와 new 선언으로 만든 클래스 메소드가 올 수 있다.     

- 변수 생성하는 방법
1. 메소드에 리턴값이 있으면 우선 변수로 받는다.      
2. 선언한 변수가 행동이 일어나서 결과값이 생길때
ex) int x = 10; int y = 10;
    int sum = x + y; // sum으로 데이터를 받는다.        
3. 함수가 어려우면 메인함수에 코딩

## 6교시
문제풀이

## 7교시
- 조건	
```	
	//1.콤마로 배열생성
	//2.느낌표 제거할 것
  	//3.문자를 숫자로 변환 ex)int x = Integer.parseInt("100");
	//4.1000 미만 숫자 중 가장 큰 수 구하기
	//5.최종 결과값에서 곱하기 2를 해서 리턴 하기
```

1. 내가 처음 푼 방식
```
		String array[] = word.split(",");
		// for (int i = 1; i < array.length; i++) {
		// String temp = array[i].replace("!","");
		// int x = Integer.parseInt(temp);

		word = word.replace("!", ""); // word에 저장해도 결과는 나오지만 다른 문자에 저장하는 게 나을거 같다.
		int 배열 = Integer.parseInt(word);
		int max = 0;
		for (int i = 0; i < array.length; i++) { // i로 조건을 만들었기 때문에 위에 있는 array와 메소드들을 for문 안에 표현해주는 걸로 바꿔야 함. <= 아마 오류의 원인
			if (배열 < 1000 && 배열 > max) {
				max = 배열;
			}
		}
		return (max * 2);
	}

	public static void main(String[] args) {
		String word = "101,1,10,1000,!100!,2000";
		int a = getResult(word);
		System.out.println(a);
	}
	
	이렇게 풀면 오류는 없다고 나오지만 결과값이 에러난다.
```

2. 수정한 식
```
	public static int getResult(String word) {
		String array[] = word.split(",");  // 콤마로 배열생성
		int max = 0;
		for (int i = 0; i < array.length; i++) { 
			String temp = array[i].replace("!", ""); // 숫자로 비교해야되므로 for문 안에 조건을 넣어서 숫자로만 표현되게 만들어준다.
			int x = Integer.parseInt(temp); //문자(temp)를 숫자 x로 변환
			if (x < 1000 && x > max) {
				max = x;
			}
		}
		return max * 2;
	}

	public static void main(String[] args) {
		String word = "101,1,10,1000,!100!,2000";
		System.out.println(getResult(word));
	}
```

3. 선생님 답
```
	public static int getResult(String word) {
		String array[] = word.split(",");
		int max = 0;
		for (int i = 0; i < array.length; i++) {
			String replaceStr = array[i].replace("!", "");
			int temp = Integer.parseInt(replaceStr);
			if (temp < 1000) {
				if (max < temp) {
					max = temp;
				}
			}
		}
		return max * 2;
	}

	public static void main(String[] args) {
		String word = "101,1,10,1000,!100!,2000";
		System.out.println(getResult(word));
	}
```
