```
선생님이 올려준 jdk 설치, 설정 방법 확인하기
샘 깃허브 JAVA/설치&설정_방법 에 있음
```
```
메소드 작성시 타입으로 VO를 안 쓰는 회사에선 Map을 사용함
    Map<String, Object>
Map이 vo 역할을 한다(Key와 value 역할)
=> Map과 VO의 차이 구글에 검색해보기
(대부분 VO를 많이 쓰긴 한다.)
VO는 클래스 이름으로 하다보니 유지보수하기 더 편함
```
```
select 할 때는 리턴 타입을 map으로 하고
insert delete update 할 때는 리턴타입을 vo로 한다?
```
```
자바
컬렉션 종류 중 List랑 Map 위주로 사용함
```
```java
package test;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

//List와 Map을 알아보자!
class 햄버거{
	private String 햄버거이름;
	private int 햄버거가격;
	private String 매장이름;
	
	public String get매장이름() {
		return 매장이름;
	}
	public void set매장이름(String 매장이름) {
		this.매장이름 = 매장이름;
	}
	public String get햄버거이름() {
		return 햄버거이름;
	}
	public void set햄버거이름(String 햄버거이름) {
		this.햄버거이름 = 햄버거이름;
	}
	public int get햄버거가격() {
		return 햄버거가격;
	}
	public void set햄버거가격(int 햄버거가격) {
		this.햄버거가격 = 햄버거가격;
	}
}

class EmpVO{
	private int empNo;
	private String ename;
	
	public int getEmpNo() {
		return empNo;
	}
	public void setEmpNo(int empNo) {
		this.empNo = empNo;
	}
	public String getEname() {
		return ename;
	}
	public void setEname(String ename) {
		this.ename = ename;
	}
}

public class 긴급점검50 {
	public static void main(String[] args) {
		ArrayList<String> list = new ArrayList<String>();
		List<String> list2 = new ArrayList<String>();
//		컬렉션즈는 클래스만 담을 수 있다
//		List는 부모, ArrayList는 자식
//		부모로 호출하면 List 뿐만 아니라 LinkedList나 Vector도 불러올 수 있다.
//		list2 = new LinkedList<String>(); // 이렇게 재활용할 수 있다.
		list2.add("hello");
		list2.add("name");
		List<햄버거> list3 = new ArrayList<햄버거>();
		햄버거 불고기버거 = new 햄버거();
		불고기버거.set햄버거가격(3000);
		불고기버거.set햄버거이름("불고기버거");
		list3.add(불고기버거);
//		스프링의 MyBatis에서 sql결과로 나온 데이터를 자동으로 new, set, add 해준다.
		
//		List도 Class이므로 다음도 가능하다 (실제로 이렇게 쓰지는 않음)
		List<ArrayList<String>> list4 = new ArrayList<ArrayList<String>>();
//		-------------------------------------------------------------------
//		하나의 map에서 value로 String과 Integer모두 사용하고 싶다면 Object를 value로 하면 된다.
		Map<String,Object> map2 = new HashMap<String, Object>();
		map2.put("햄버거이름", "불고기버거"); // key와 value
		map2.put("햄버거가격", 1000);
		System.out.println(map2.get("햄버거이름"));
		System.out.println(map2.get("햄버거가격"));
		
		System.out.println(list3.get(0).get햄버거이름());
		System.out.println(list3.get(0).get햄버거가격());
//		list와 map의 결과는 같다.
		
//		문제) list3에 매장이름추가
//		우선 햄버거 클래스의 변수로 매장이름 추가
		불고기버거.set매장이름("롯데리아");
		list3.add(불고기버거);
//		또는 map으로 매장이름 추가
		map2.put("매장이름", "롯데리아"); // 특이한 점) 기존 map2에 있던 햄버거이름과 햄버거가격 뒤에 들어가는게 아니라 그 사이로 매장이름이 들어감 
		
		List<Map<String, Object>> mapList = new ArrayList<Map<String,Object>>();
//		문제) mapList 0번째에 햄버거 이름과 가격을 추가
		Map<String, Object> map3 = new HashMap<String, Object>();
		map3.put("햄버거 이름", "게살버거");
		map3.put("햄버거 가격", 1000);
		mapList.add(map3);
		mapList.add(map2); // 리스트 확인용
		System.out.println(mapList); // [{map3}, {map2}] 로 출력됨
		System.out.println(mapList.get(0));
		
//		EmpVO를 담는 list
		List<EmpVO> empList = new ArrayList<EmpVO>();
		EmpVO vo = new EmpVO();
		vo.setEmpNo(10);
		vo.setEname("유영준");
		empList.add(vo);
		System.out.println(vo.getEmpNo()+", "+vo.getEname());
		
		List<Map<String, Object>> empMapList = new ArrayList<Map<String,Object>>();
		Map<String,Object> map4 = new HashMap<String, Object>();
//		map4.put("유영준", 10); list와 map을 비교하기 위해서 아래 방법을 사용한다.
		map4.put("empNo", 10);
		map4.put("ename", "유영준");
		empMapList.add(map4);
		System.out.println(empMapList);
//		list에 넣는 과정과 map에 추가하는 과정이 같다.
//		다만, list는 VO가 필요하고 Map은 VO없이 바로 데이터를 key와 value로 넣는다.
//		-------------------------------------------------------------------		
//		MyBatis는 DB에서 데이터를 불러와서 list의 add까지의 과정을 대신 해준 것처럼 map에서도 put의 과정을 대신 해준다.
//		DB의 데이터를 list에 set 해주는 걸 mapping이라고 함
//		Map으로 데이터 넣기
		Map<String,Object> SMITH = new HashMap<String,Object>();
		SMITH.put("empNo", 7369);
		SMITH.put("ename", "SMITH");
		
		Map<String,Object> ALLEN = new HashMap<String,Object>();
		ALLEN.put("empNo", 7499);
		ALLEN.put("ename", "ALLEN");
//		List로 데이터 넣기
		List<EmpVO> empList2 = new ArrayList<EmpVO>();
		EmpVO vo2 = new EmpVO();
		vo2.setEmpNo(7369);
		vo2.setEname("SMITH");
		empList2.add(vo2);
		
		EmpVO vo3 = new EmpVO();
		vo3.setEmpNo(7499);
		vo3.setEname("ALLEN");
		empList2.add(vo3);
//		쿼리 결과 컬럼과 VO에 있는 필드변수 이름은 동일해야 한다
//		but HashMap은 이름과 상관없이 바로 들어간다.
		
//		List에서 Get
		System.out.println(empList2.get(0).getEmpNo()); // 7369
		System.out.println(empList2.get(0).getEname()); // SMITH
//		Map에서 Get
		System.out.println(SMITH.get("empNo")); // 7369
		System.out.println(SMITH.get("ename")); // SMITH
	}
}
```
```
select : map
    이유 : 조인이 많아지면 필드변수가 늘어나기 때문(노가다해야 함)
    장점 : 컬럼이름에 맞게 알아서 매핑됨
    단점 : 안에 어떤게 들어있는지 확인하기 어려움(sql 들어가서 확인)
delete, update, insert : vo
    장점 : vo클래스에 미리 필드변수를 정의해서 문서화, 유지보수 가능
    (중요한 건 무조건 vo)

vo의 장점 ) 어떤게 리턴될지 미리 알 수 있음
     단점 ) 테이블이 많아지고 join이 많아지면 변수를 전부 입력하는 노가다를 해야 됨
```
```
spring으로 짠 로직을 디버깅하는 방법(postman 사용)
    spring로직 중 controller에서 정의한 주소를 postman으로 입력하기 때문에 디버깅하기 위해선 중간에 포스트맨의 실행이 필요하다.

    1. 비즈니스로직을 짠 서비스에서 디버깅할 라인에 더블클릭으로 점 만들기
    2. f11로 디버깅 시작하면 오류 화면으로 넘어감
    3. 포스트맨에서 send 눌러서 컨트롤러가 신호를 받게 함
    4. f8을 누르면 서비스의 쿼리화면으로 오고 f6 눌러서 한 줄씩 확인
```
```
로그 : 이벤트에 대한 기록
스프링에서 실행하면 언제 어떤게 실행됐는지 기록이 됨(로그)

실행하면 상단에 나오는 이미지와 텍스트 커스텀하기
    1. resources 패키지 아래에 banner.txt파일 만들기
        (오른쪽클릭 - new - other - general - file 선택해서 만듦)
    2. 해당 파일에 원하는 글 입력해주면 된다.
        파일을 보면 title과 version이 있는데 이건 yaml파일에서 추가한다.
    3. application.yaml 파일에서 title과 version을 추가한다.
        (java 읽기 전에 yaml 파일 읽기 때문)

로그백 추가하기
    로그백 파일을 resources 아래에 넣는다.
```