```
통계를 낼 때(게시판에서 학생수, 게시글 수, 작성자 수, 조회 수 등)
    1. 통계 테이블을 따로 만듦 <= 통계의 양이 방대할 때 사용
        (특정 시간이 되면 쿼리로 조회한 통계를 테이블에 insert함)
    2. 쿼리로 조회
        => 통계를 한번에 내기 위해 서브쿼리 사용
```
```
페이징은 고객의 요구에 따라 수정할 수 있게끔 알고리즘을 잘 짜야 한다.
1. 해당 테이블의 전체 카운트 쿼리
2. 페이지에 보여질 게시글을 나누는 쿼리
    select *
    from emp
    limit 0,5
        ===> limit(startPage, pageSize)
```
```java
package 페이징;

public class PageHandler {
	public static void main(String[] args) {
//		STEP 1. 페이지 수 알아내기(총 카운트와 한 페이지에 몇 개를 보여줄지가 중요함)
		// 여신강림 페이징
		// 야옹이 작가는 210화까지 연재함. 1페이지에 10화를 보여줄 수 있다.
		int total = 211; // sql에서 count함
		int pages = 0;
		int pageSize = 10; // 1페이지에 보여줄 수 있는 게시물 수
		pages = total / pageSize;
		if(total % pageSize >= 1) ++pages; // 나머지가 있으면 페이지수 1개 추가
		System.out.println("총 "+pages+"개 페이지"); // 22
		System.out.println("한 페이지에 보여줄 게시물 : "+pageSize+"개");
		
//		STEP 2. 블록 알아내기(한 블록은 사용자한테 보여주는 페이지 뭉치 ex. 1~10페이지 까지가 한 블록)
		int navigatePages = 10; // 한 블록에 몇 페이지를 보여줄지
		int blocks = 0;
		blocks = pages / navigatePages;
		if(pages % navigatePages >= 1) ++blocks;
		System.out.println("총 "+blocks+"개 블럭"); // 3
		
//		STEP 3. 현재 있는 블록 알아내기
		int pageNum = 21; // 지금 있는 페이지
		int nowBlock = 0;
		// 내 풀이1
//		if(pageNum >= 1) { // 지금 페이지가 1보다 크면 블럭 1 추가(기본 블럭 = 1)
//			++nowBlock;
//		}
//		nowBlock += (pageNum / pageSize);
//		if(pageNum % pageSize == 0) {
//			--nowBlock;
//		}
		
		// 내 풀이2
//		nowBlock = 1 + (pageNum / pageSize);
//		if(pageNum % pageSize == 0) {
//			--nowBlock;
//		}
		
		// 선생님 풀이
		nowBlock = pageNum / navigatePages;
		if(pageNum % navigatePages > 0) {
			++nowBlock;
		}
		System.out.println("현재 블럭 : "+nowBlock+"블럭");
		
//		STEP 4. 마지막 블록 알아내기
		int lastBlock = 0;
//		total(총 게시물 수), navigatePages(한 블록에 보여지는 페이지), pageSize(한 페이지에 보여지는 게시물 수) 이용
		lastBlock = total / (navigatePages * pageSize);
		if(total % (navigatePages * pageSize) > 0) {
			++lastBlock;
		}
		System.out.println("마지막 블럭 : "+lastBlock+"블럭");
		
//		STEP 5. 현재 내가 위치한 블럭의 처음 페이지와 마지막 페이지 구하기
//		ex) 1블록에 있으면 1~10, 3블록에 있으면 21~22(여신강림 기준)
//		startpage를 먼저 구함
		int startPage = 0;
		int endPage = 0;
		
//		if(nowBlock == 1) { // 처음 페이지
//			startPage = 1;
//		}else {
//			startPage = (nowBlock-1) * pageSize + 1;			
//		}
//
//		if(nowBlock == 1) { // 마지막 페이지
//			endPage = 10;
//		}else {
//			endPage = nowBlock * pageSize;
//		}
//		
//		if(nowBlock == lastBlock) { // 마지막 블록이라면 마지막 페이지로 총 페이지 수 대입
//			endPage = pages;
//		}
		
//		startPage = (nowBlock-1) * navigatePages + 1;
		startPage = (nowBlock * navigatePages) - (navigatePages -1); // 선생님 풀이
		endPage = nowBlock * navigatePages;
		if(nowBlock == lastBlock) { // 마지막 블록이라면 마지막 페이지로 총 페이지 수 대입
			endPage = pages;
		}
		System.out.println("처음 페이지 : "+startPage+", 마지막 페이지 : "+endPage);
		
//		STEP 6. 이전버튼, 다음버튼 유무 판단
		boolean hasPreviousPage = true;
		boolean hasNextPage = true;
		
		if(lastBlock == 1) { // 블럭이 하나이므로 이전, 다음 버튼 존재 X
			hasPreviousPage = false;
			hasNextPage = false;
		}
		if(lastBlock > 1 && lastBlock == nowBlock) { // 마지막 블럭이라면 이전 버튼만 존재
			hasPreviousPage = true;
			hasNextPage = false;
		}
		if(lastBlock > 1 && pageNum <= navigatePages) { // 첫번째 블럭인데 블럭이 1 이상일 경우 다음 버튼 존재
			// pageNum이 navigatePages 보다 작은 경우는 1블럭만 해당됨
			hasPreviousPage = false;
			hasNextPage = true; 
		}
		System.out.println("이전 버튼이 있습니까? "+hasPreviousPage);
		System.out.println("다음 버튼이 있습니까? "+hasNextPage);
	}
	
//	각 STEP을 메소드로 나눈다.
}
```